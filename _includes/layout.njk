<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="{{ '/img/favicon/apple-touch-icon.png' | addHash }}"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="{{ '/img/favicon/favicon-32x32.png' | addHash }}"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="{{ '/img/favicon/favicon-16x16.png' | addHash }}"
    />
    <link rel="stylesheet" href="{{ '/styles.min.css' | addHash }}" />

    <title>{{ site.title }}</title>
  </head>
  <body>
    <header>
      <nav>
        <h1>
          <a href="/"> {{ site.title }} </a>
        </h1>
      </nav>
      <canvas id="mt-fuji"></canvas>
      {% if title %}
      <h1>{{ title }}</h1>
      <p>
        <date>{{ date | formatDate }}</date>
      </p>
      {% endif %}
    </header>
    <main>
      <section>
        {{ content | safe }}
      </section>
    </main>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.0.0/quicklink.umd.js"></script>
    <script>
      window.addEventListener('load', () => {
        quicklink.listen();
      });
    </script>
    <script>
      (function () {
        var canvas = document.getElementById('mt-fuji');
        if (!canvas) return;
        var ctx = canvas.getContext('2d');
        var SEGS = 9, rotY = 0, W = 1, H = 1;

        function resize() {
          W = Math.max(1, Math.round(canvas.clientWidth * 0.5));
          H = Math.max(1, Math.round(canvas.clientHeight * 0.5));
          canvas.width = W;
          canvas.height = H;
        }
        resize();
        window.addEventListener('resize', resize);

        // Vector math helpers
        function norm3(v) {
          var l = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]) || 1;
          return [v[0]/l, v[1]/l, v[2]/l];
        }
        function cross3(a, b) {
          return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
        }
        function dot3(a, b) { return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }

        // Camera
        var EYE = [0, 3, 12];
        var FWD   = norm3([0, 2-3, 0-12]);
        var RIGHT = norm3(cross3(FWD, [0, 1, 0]));
        var UP    = cross3(RIGHT, FWD);
        var HALF_TAN = Math.tan(25 * Math.PI / 180);

        // Lighting
        var SUN   = norm3([5, 8, 3]);
        var AMB   = [0x33/255*0.8, 0x44/255*0.8, 0x77/255*0.8];
        var SUN_C = [0xff/255*1.2, 0xd0/255*1.2, 0xa0/255*1.2];

        // Fewer stars
        var stars = [];
        for (var i = 0; i < 60; i++) {
          stars.push([(Math.random()-0.5)*50, Math.random()*20+2, (Math.random()-0.5)*50-15]);
        }

        function project(wx, wy, wz) {
          var dx=wx-EYE[0], dy=wy-EYE[1], dz=wz-EYE[2];
          var cx=dot3([dx,dy,dz], RIGHT);
          var cy=dot3([dx,dy,dz], UP);
          var cz=dot3([dx,dy,dz], FWD);
          if (cz < 0.01) return null;
          var f = (H*0.5) / HALF_TAN;
          return [cx/cz*f + W*0.5, -cy/cz*f + H*0.5, cz];
        }

        function rotPt(p, ry) {
          var c=Math.cos(ry), s=Math.sin(ry);
          return [c*p[0]+s*p[2], p[1], -s*p[0]+c*p[2]];
        }

        function shade(base, wv) {
          var ab=[wv[1][0]-wv[0][0], wv[1][1]-wv[0][1], wv[1][2]-wv[0][2]];
          var ac=[wv[2][0]-wv[0][0], wv[2][1]-wv[0][1], wv[2][2]-wv[0][2]];
          var n = norm3(cross3(ab, ac));
          var d = Math.max(0, dot3(n, SUN));
          var b0=base[0]/255, b1=base[1]/255, b2=base[2]/255;
          return 'rgb('+
            Math.round(Math.min(255, b0*(AMB[0]+d*SUN_C[0])*255))+','+
            Math.round(Math.min(255, b1*(AMB[1]+d*SUN_C[1])*255))+','+
            Math.round(Math.min(255, b2*(AMB[2]+d*SUN_C[2])*255))+')';
        }

        // LatheGeometry with explicit color; capTop=true adds a flat disc at the top
        function buildLathe(prof, col, capTop) {
          var verts=[], faces=[], pn=prof.length;
          for (var seg=0; seg<=SEGS; seg++) {
            var ang=(seg/SEGS)*Math.PI*2;
            for (var pi=0; pi<pn; pi++)
              verts.push([prof[pi][0]*Math.cos(ang), prof[pi][1], prof[pi][0]*Math.sin(ang)]);
          }
          for (var seg=0; seg<SEGS; seg++)
            for (var pi=0; pi<pn-1; pi++) {
              var va=seg*pn+pi, vb=seg*pn+pi+1, vc=(seg+1)*pn+pi+1, vd=(seg+1)*pn+pi;
              faces.push({v:[va,vb,vc,vd], c:col});
            }
          if (capTop) {
            var topY=prof[pn-1][1], ci=verts.length;
            verts.push([0, topY, 0]);
            for (var seg=0; seg<SEGS; seg++) {
              var nxt=(seg+1)%SEGS;
              faces.push({v:[ci, nxt*pn+(pn-1), seg*pn+(pn-1)], c:col});
            }
          }
          return {verts:verts, faces:faces};
        }

        // CylinderGeometry with explicit color
        function buildCylinder(rT, rB, h, col) {
          var verts=[], faces=[];
          for (var seg=0; seg<=SEGS; seg++) {
            var ang=(seg/SEGS)*Math.PI*2;
            verts.push([rT*Math.cos(ang), h*0.5, rT*Math.sin(ang)]);
            verts.push([rB*Math.cos(ang), -h*0.5, rB*Math.sin(ang)]);
          }
          for (var seg=0; seg<SEGS; seg++)
            faces.push({v:[seg*2, (seg+1)*2, (seg+1)*2+1, seg*2+1], c:col});
          // Top cap (winding reversed so normal points up toward camera)
          var ci=verts.length;
          verts.push([0, h*0.5, 0]);
          for (var seg=0; seg<SEGS; seg++) {
            var nxt=(seg+1)%SEGS;
            faces.push({v:[ci, nxt*2, seg*2], c:col});
          }
          return {verts:verts, faces:faces};
        }

        // Two-part profile split at snow line â€” lower dark rock, upper snow cap.
        // Both share the seam point so the surface is seamless.
        var LOWER = [[4.5,0],[4.3,0.3],[3.8,0.8],[3.1,1.5],[2.3,2.3],[1.6,3.1]];
        var UPPER = [[1.6,3.1],[1.0,3.8],[0.4,4.5],[0.3,5]];
        var MESHES = [
          buildLathe(LOWER, [42,46,58]),       // dark charcoal volcanic rock
          buildLathe(UPPER, [228,234,242], true), // snow cap with flat top
          buildCylinder(4.8, 5.1, 0.4, [32,58,32])
        ];

        function render() {
          ctx.fillStyle = '#1a2744';
          ctx.fillRect(0, 0, W, H);

          // Stars
          ctx.fillStyle = 'rgba(255,255,255,0.85)';
          for (var i=0; i<stars.length; i++) {
            var p=project(stars[i][0], stars[i][1], stars[i][2]);
            if (p) ctx.fillRect(Math.round(p[0]), Math.round(p[1]), 1, 1);
          }

          // Collect all faces with rotated world verts and projected screen coords
          var allFaces = [];
          for (var mi=0; mi<MESHES.length; mi++) {
            var mesh=MESHES[mi];
            for (var fi=0; fi<mesh.faces.length; fi++) {
              var face=mesh.faces[fi];
              var wv=[], pv=[], skip=false;
              for (var vi=0; vi<face.v.length; vi++) {
                wv.push(rotPt(mesh.verts[face.v[vi]], rotY));
              }
              for (var vi=0; vi<wv.length; vi++) {
                var pp=project(wv[vi][0], wv[vi][1], wv[vi][2]);
                if (!pp) { skip=true; break; }
                pv.push(pp);
              }
              if (skip) continue;
              var depth=0;
              for (var vi=0; vi<pv.length; vi++) depth+=pv[vi][2];
              allFaces.push({pv:pv, wv:wv, c:face.c, depth:depth/pv.length});
            }
          }

          // Painter's algorithm: draw back-to-front
          allFaces.sort(function(a,b) { return b.depth-a.depth; });
          for (var fi=0; fi<allFaces.length; fi++) {
            var f=allFaces[fi];
            ctx.fillStyle = shade(f.c, f.wv);
            ctx.beginPath();
            ctx.moveTo(f.pv[0][0], f.pv[0][1]);
            for (var vi=1; vi<f.pv.length; vi++) ctx.lineTo(f.pv[vi][0], f.pv[vi][1]);
            ctx.closePath();
            ctx.fill();
          }
        }

        (function loop() {
          requestAnimationFrame(loop);
          rotY += 0.006;
          render();
        })();
      })();
    </script>
  </body>
</html>
